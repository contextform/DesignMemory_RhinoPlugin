using System;
using System.Net.Http;
using System.Text;
using System.Threading.Tasks;
using Newtonsoft.Json;
using Contextform.Models;
using Contextform.Utils;
using Rhino;

namespace Contextform.API
{
    public class ClaudeClient
    {
        private readonly HttpClient _httpClient;
        private const string CLAUDE_API_URL = "https://api.anthropic.com/v1/messages";

        public ClaudeClient()
        {
            _httpClient = new HttpClient();
        }

        public async Task<string> GenerateScript(DesignMemory memory, string prompt)
        {
            try
            {
                var settings = SettingsManager.Instance;
                
                // For MVP, use free endpoint by default
                if (settings.UseFreeEndpoint || string.IsNullOrEmpty(settings.ClaudeApiKey))
                {
                    return await CallFreeEndpoint(memory, prompt);
                }
                else
                {
                    return await CallClaudeAPI(memory, prompt);
                }
            }
            catch (Exception ex)
            {
                RhinoApp.WriteLine($"Error generating script: {ex.Message}");
                return null;
            }
        }

        private async Task<string> CallFreeEndpoint(DesignMemory memory, string prompt)
        {
            var settings = SettingsManager.Instance;
            var requestBody = new
            {
                memory = memory,
                prompt = prompt
            };

            var json = JsonConvert.SerializeObject(requestBody);
            var content = new StringContent(json, Encoding.UTF8, "application/json");

            var response = await _httpClient.PostAsync(settings.FreeApiEndpoint, content);
            var responseContent = await response.Content.ReadAsStringAsync();

            if (response.IsSuccessStatusCode)
            {
                var result = JsonConvert.DeserializeObject<FreeEndpointResponse>(responseContent);
                return result?.Script;
            }
            else
            {
                RhinoApp.WriteLine($"Free API error: {response.StatusCode} - {responseContent}");
                return GenerateFallbackScript(memory, prompt); // Fallback for MVP
            }
        }

        private async Task<string> CallClaudeAPI(DesignMemory memory, string prompt)
        {
            var settings = SettingsManager.Instance;
            
            _httpClient.DefaultRequestHeaders.Clear();
            _httpClient.DefaultRequestHeaders.Add("x-api-key", settings.ClaudeApiKey);
            _httpClient.DefaultRequestHeaders.Add("anthropic-version", "2023-06-01");

            var systemPrompt = CreateSystemPrompt();
            var userPrompt = CreateUserPrompt(memory, prompt);

            var requestBody = new
            {
                model = "claude-3-5-sonnet-20241022",
                max_tokens = 4000,
                system = systemPrompt,
                messages = new[]
                {
                    new { role = "user", content = userPrompt }
                }
            };

            var json = JsonConvert.SerializeObject(requestBody);
            var content = new StringContent(json, Encoding.UTF8, "application/json");

            var response = await _httpClient.PostAsync(CLAUDE_API_URL, content);
            var responseContent = await response.Content.ReadAsStringAsync();

            if (response.IsSuccessStatusCode)
            {
                var result = JsonConvert.DeserializeObject<ClaudeResponse>(responseContent);
                return ExtractScriptFromResponse(result.Content[0].Text);
            }
            else
            {
                RhinoApp.WriteLine($"Claude API error: {response.StatusCode} - {responseContent}");
                return null;
            }
        }

        private string GenerateFallbackScript(DesignMemory memory, string prompt)
        {
            // Simple fallback script for demo purposes
            return @"
                // Generated by Contextform - Demo Script
                var sphere = new Sphere(Point3d.Origin, 5.0);
                var brep = sphere.ToBrep();
                doc.Objects.AddBrep(brep);
                
                RhinoApp.WriteLine(""Demo transformation applied: "" + prompt);
            ";
        }

        private string CreateSystemPrompt()
        {
            return @"You are a Rhino 3D modeling expert that generates C# RhinoCommon scripts based on design memory and user prompts.

Your task is to:
1. Analyze the captured design memory (sequence of Rhino commands)
2. Understand the design intent from the command sequence
3. Generate a new C# RhinoCommon script that creates geometry based on the user's transformation request
4. The script should replace the original geometry with the new transformed version

Important guidelines:
- Use only RhinoCommon API calls
- Generate complete, executable C# code
- Include proper using statements
- Handle geometry creation, transformation, and cleanup
- The script will be executed directly in Rhino
- Focus on the geometric transformation requested by the user
- Maintain the overall design structure while applying the requested changes

Return only the C# script code, wrapped in ```csharp code blocks.";
        }

        private string CreateUserPrompt(DesignMemory memory, string prompt)
        {
            var memoryJson = memory.ToJson();
            
            return $@"Design Memory (captured modeling session):
{memoryJson}

User Request: {prompt}

Original geometry IDs to replace: {string.Join(", ", memory.OriginalGeometryIds)}

Please generate a C# RhinoCommon script that:
1. Creates new geometry based on the design memory and user request
2. Replaces the original geometry with the new transformed version
3. Maintains the design intent while applying the requested transformation";
        }

        private string ExtractScriptFromResponse(string response)
        {
            // Extract C# code from markdown code blocks
            var startMarker = "```csharp";
            var endMarker = "```";
            
            var startIndex = response.IndexOf(startMarker);
            if (startIndex == -1) return response; // No code block found, return as-is
            
            startIndex += startMarker.Length;
            var endIndex = response.IndexOf(endMarker, startIndex);
            
            if (endIndex == -1) return response.Substring(startIndex).Trim();
            
            return response.Substring(startIndex, endIndex - startIndex).Trim();
        }

        private class ClaudeResponse
        {
            [JsonProperty("content")]
            public ClaudeContent[] Content { get; set; }
        }

        private class ClaudeContent
        {
            [JsonProperty("text")]
            public string Text { get; set; }
        }

        private class FreeEndpointResponse
        {
            [JsonProperty("script")]
            public string Script { get; set; }
            
            [JsonProperty("success")]
            public bool Success { get; set; }
        }
    }
}